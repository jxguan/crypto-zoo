-- Import Data Script for Crypto Zoo
-- This script imports vertices and edges from JSON data into Supabase

-- Clear existing data
DELETE FROM edges;
DELETE FROM vertices;

-- Import vertices data
INSERT INTO vertices (id, name, abbreviation, type, tags, description, definition, references_data, related_vertices, notes, wip) VALUES
('owf', 'One-Way Function', 'OWF', 'primitive', ARRAY['foundational'], 'A function that is easy to compute on every input, but hard to invert given the image of a random input.', 'One-way functions are fundamental building blocks in cryptography. They are functions that are computationally easy to evaluate but computationally difficult to invert. Formally, a function $f: \{0,1\}^* \rightarrow \{0,1\}^*$ is one-way if it can be computed by a polynomial-time algorithm, but any polynomial-time randomized algorithm that attempts to invert $f$ on a random input succeeds with negligible probability.', '[{"title": "Foundations of Cryptography: Basic Tools", "author": "Oded Goldreich", "year": 2001, "url": "https://www.wisdom.weizmann.ac.il/~oded/foc-vol1.html"}]', ARRAY[]::TEXT[], '', false),

('prg', 'Pseudorandom Generator', 'PRG', 'primitive', ARRAY['symmetric'], 'A deterministic algorithm that takes a short random seed and expands it into a longer pseudorandom string.', 'A pseudorandom generator is a deterministic algorithm that takes a short random seed and expands it into a longer pseudorandom string that is computationally indistinguishable from a truly random string of the same length. Formally, a PRG $G: \{0,1\}^n \rightarrow \{0,1\}^{\ell(n)}$ where $\ell(n) > n$ is pseudorandom if for all PPT distinguishers $D$, $|\Pr[D(G(U_n)) = 1] - \Pr[D(U_{\ell(n)}) = 1]| \leq \text{negl}(n)$. PRGs are essential for many cryptographic applications including stream ciphers and key generation.', '[{"title": "Theory of Cryptography", "author": "Jonathan Katz and Yehuda Lindell", "year": 2014, "url": "https://www.cs.umd.edu/~jkatz/imc.html"}]', ARRAY[]::TEXT[], '', false),

('prf', 'Pseudorandom Function', 'PRF', 'primitive', ARRAY['symmetric'], 'A family of functions that are computationally indistinguishable from truly random functions.', 'A pseudorandom function family is a collection of efficiently computable functions that are computationally indistinguishable from truly random functions. Formally, a PRF family $\{F_k: \{0,1\}^n \rightarrow \{0,1\}^m\}_{k \in \{0,1\}^\lambda}$ is pseudorandom if for all PPT distinguishers $D$, $|\Pr[D^{F_k(\cdot)}(1^\lambda) = 1] - \Pr[D^{R(\cdot)}(1^\lambda) = 1]| \leq \text{negl}(\lambda)$ where $R$ is a truly random function. PRFs are used in many cryptographic constructions including message authentication codes, key derivation functions, and more.', '[{"title": "How to Construct Random Functions", "author": "Oded Goldreich, Shafi Goldwasser, and Silvio Micali", "year": 1986, "url": "https://doi.org/10.1145/12130.12134"}]', ARRAY[]::TEXT[], '', false),

('hash', 'Cryptographic Hash Function', 'Hash', 'primitive', ARRAY['symmetric'], 'A function that takes an input of arbitrary length and produces a fixed-size output, with properties like collision resistance and preimage resistance.', 'A cryptographic hash function is a mathematical function that takes an input of arbitrary length and produces a fixed-size output. Formally, a hash function $H: \{0,1\}^* \rightarrow \{0,1\}^n$ should satisfy properties like collision resistance (hard to find $x \neq y$ such that $H(x) = H(y)$), preimage resistance (hard to find $x$ given $H(x)$), and second preimage resistance (hard to find $y \neq x$ given $x$ such that $H(x) = H(y)$).', '[{"title": "Cryptographic Hash Functions", "author": "Ivan Damg책rd", "year": 1989, "url": "https://doi.org/10.1007/0-387-34805-0_39"}]', ARRAY[]::TEXT[], '', false),

('mac', 'Message Authentication Code', 'MAC', 'primitive', ARRAY['symmetric'], 'A cryptographic primitive that provides authentication and integrity for messages using a shared secret key.', 'A message authentication code is a cryptographic primitive that provides authentication and integrity for messages. Formally, a MAC consists of algorithms $(\text{Gen}, \text{Mac}, \text{Vrfy})$ where $\text{Mac}_k(m) = t$ produces a tag $t$ for message $m$ using key $k$, and $\text{Vrfy}_k(m, t)$ outputs 1 if $t$ is a valid tag for $m$ under key $k$, and 0 otherwise.', '[{"title": "Message Authentication Codes", "author": "Mihir Bellare, Ran Canetti, and Hugo Krawczyk", "year": 1996, "url": "https://doi.org/10.1007/3-540-68697-5_1"}]', ARRAY[]::TEXT[], '', false),

('pke', 'Public Key Encryption', 'PKE', 'primitive', ARRAY['public key'], 'An encryption scheme where the encryption key is public and the decryption key is private.', 'Public key encryption is a cryptographic primitive that allows secure communication without requiring a shared secret key. It consists of three algorithms: $(\text{Gen}, \text{Enc}, \text{Dec})$ where $\text{Gen}$ generates a public key $pk$ and private key $sk$, $\text{Enc}_{pk}(m)$ encrypts message $m$ using the public key, and $\text{Dec}_{sk}(c)$ decrypts ciphertext $c$ using the private key.', '[{"title": "New Directions in Cryptography", "author": "Whitfield Diffie and Martin Hellman", "year": 1976, "url": "https://doi.org/10.1109/TIT.1976.1055638"}]', ARRAY[]::TEXT[], '', false),

('ke', 'Key Exchange', 'KE', 'primitive', ARRAY['public key'], 'A protocol that allows two parties to establish a shared secret key over an insecure channel.', 'Key exchange is a cryptographic protocol that allows two parties to establish a shared secret key over an insecure channel. The security of the protocol ensures that an eavesdropper cannot learn the shared secret. Key exchange protocols are fundamental building blocks for secure communication.', '[{"title": "New Directions in Cryptography", "author": "Whitfield Diffie and Martin Hellman", "year": 1976, "url": "https://doi.org/10.1109/TIT.1976.1055638"}]', ARRAY[]::TEXT[], '', false);

-- Import edges data
INSERT INTO edges (id, type, name, overview, theorem, construction, proof_sketch, source_vertices, target_vertices, tags, model, references_data, notes, wip) VALUES
('owf-to-prg', 'construction', 'OWF to PRG Construction', 'This construction shows that if one-way functions exist, then pseudorandom generators exist. The construction uses the Goldreich-Levin hardcore bit technique to extract pseudorandom bits from a one-way function. Given a one-way function $f$, we construct a PRG $G(x,r) = (f(x), \langle x,r \rangle)$ where $\langle x,r \rangle$ is the inner product modulo 2.', 'If one-way functions exist, then pseudorandom generators exist.', 'Given a one-way function $f$, we construct a PRG $G(x,r) = (f(x), \langle x,r \rangle)$ where $\langle x,r \rangle$ is the inner product modulo 2. The construction uses the Goldreich-Levin hardcore bit technique to extract pseudorandom bits from a one-way function.', 'The security proof shows that if an adversary can distinguish the output of $G$ from random, then we can invert the one-way function $f$. The key insight is that $\langle x,r \rangle$ is a hardcore predicate for $f$, meaning it is unpredictable even given $f(x)$. If the adversary can predict $\langle x,r \rangle$ with non-negligible advantage, we can use this to construct an inverter for $f$.', ARRAY['owf'], ARRAY['prg'], ARRAY['symmetric'], 'plain', '[{"title": "A Hard-Core Predicate for all One-Way Functions", "author": "Oded Goldreich and Leonid A. Levin", "year": 1989, "url": "https://doi.org/10.1145/73007.73010"}]', '', false),

('owf-to-hash', 'construction', 'OWF to Hash Construction', 'This construction shows how to build collision-resistant hash functions from one-way functions using the Merkle-Damg책rd iterated construction. The construction compresses the input in stages using a compression function based on the one-way function.', 'If one-way functions exist, then collision-resistant hash functions exist.', 'We use the Merkle-Damg책rd iterated construction to build collision-resistant hash functions from one-way functions. The construction compresses the input in stages using a compression function based on the one-way function.', 'The security proof shows that finding a collision in the hash function implies finding a collision in the underlying compression function. Since the compression function is built from a one-way function, finding collisions in it would allow us to invert the one-way function. The Merkle-Damg책rd construction preserves collision resistance through the iteration process.', ARRAY['owf'], ARRAY['hash'], ARRAY['symmetric'], 'plain', '[{"title": "A Design Principle for Hash Functions", "author": "Ralph C. Merkle", "year": 1989, "url": "https://doi.org/10.1007/0-387-34805-0_39"}]', '', false),

('prg-to-prf', 'construction', 'PRG to PRF Construction', 'The Goldreich-Goldwasser-Micali (GGM) construction shows how to build a pseudorandom function from a pseudorandom generator. The construction uses the PRG to build a tree structure where each node represents a function evaluation. Given a PRG $G: \{0,1\}^n \rightarrow \{0,1\}^{2n}$, we define $F_k(x) = G_{x_n}(G_{x_{n-1}}(\cdots G_{x_1}(k) \cdots))$ where $G_0$ and $G_1$ are the left and right halves of $G$''s output.', 'If pseudorandom generators exist, then pseudorandom functions exist.', 'The Goldreich-Goldwasser-Micali (GGM) construction builds a pseudorandom function from a pseudorandom generator using a tree structure. Given a PRG $G: \{0,1\}^n \rightarrow \{0,1\}^{2n}$, we define $F_k(x) = G_{x_n}(G_{x_{n-1}}(\cdots G_{x_1}(k) \cdots))$ where $G_0$ and $G_1$ are the left and right halves of $G$''s output.', 'The security proof uses a hybrid argument. We define hybrids where we replace the PRG outputs with truly random values at different levels of the tree. If an adversary can distinguish the PRF from random, there must be a hybrid where the adversary can distinguish between PRG output and random, contradicting the security of the PRG.', ARRAY['prg'], ARRAY['prf'], ARRAY['symmetric'], 'plain', '[{"title": "How to Construct Random Functions", "author": "Oded Goldreich, Shafi Goldwasser, and Silvio Micali", "year": 1986, "url": "https://doi.org/10.1145/12130.12134"}]', '', false),

('prf-to-mac', 'construction', 'PRF to MAC Construction', 'This is a simple construction where a pseudorandom function is used directly as a message authentication code. The security of the MAC follows directly from the pseudorandomness of the PRF.', 'If pseudorandom functions exist, then secure message authentication codes exist.', 'A pseudorandom function is used directly as a message authentication code. The MAC is defined as $\text{MAC}_k(m) = F_k(m)$ where $F_k$ is a pseudorandom function.', 'The security proof shows that if an adversary can forge a MAC tag for a new message, then we can distinguish the PRF from a truly random function. The adversary''s forgery attempt can be used to construct a distinguisher that queries the function on the forged message and checks if the output matches the forged tag.', ARRAY['prf'], ARRAY['mac'], ARRAY['symmetric'], 'plain', '[{"title": "Message Authentication Codes", "author": "Mihir Bellare, Ran Canetti, and Hugo Krawczyk", "year": 1996, "url": "https://doi.org/10.1007/3-540-68697-5_1"}]', '', false),

('hash-to-mac', 'construction', 'Hash to MAC Construction', 'The HMAC construction shows how to build a message authentication code from a cryptographic hash function. HMAC uses the hash function in a specific way to provide security even if the underlying hash function has weaknesses.', 'If cryptographic hash functions exist, then secure message authentication codes exist.', 'The HMAC construction builds a MAC from a hash function using the formula $\text{HMAC}_k(m) = H(k \oplus \text{opad} \| H(k \oplus \text{ipad} \| m))$ where $H$ is the hash function and $\text{ipad}$, $\text{opad}$ are padding constants.', 'The security proof shows that HMAC is secure under the assumption that the underlying hash function is a random oracle. The key insight is that the outer and inner applications of the hash function prevent length extension attacks. The security reduces to the collision resistance and one-wayness of the hash function.', ARRAY['hash'], ARRAY['mac'], ARRAY['symmetric'], 'random oracle', '[{"title": "HMAC: Keyed-Hashing for Message Authentication", "author": "Mihir Bellare, Ran Canetti, and Hugo Krawczyk", "year": 1996, "url": "https://doi.org/10.17487/RFC2104"}]', '', false),

('pke-to-ke', 'construction', 'PKE to KE Construction', 'The 2 message KE protocol given by any PKE scheme $(\operatorname{Gen}, \operatorname{Enc}, \operatorname{Dec})$ acts as follows. The first party, Alice, will run $\operatorname{Gen}\to (pk, sk)$, and sends $pk$ to Bob. Bob picks a random message $m$, and sends $\operatorname{Enc}_{pk}(m) \to c$ to Alice. Alice then outputs $\operatorname{Dec}_{sk}(c)$, and Bob outputs $m$ directly.\n\nCorrectness follows from the fact that $\operatorname{Dec}_{sk}(c) = m$ by correctness of the PKE. Security follows from IND-CPA security of the PKE.', 'If public-key encryption schemes exist, then key exchange protocols exist.', 'A PKE scheme $(\operatorname{Gen}, \operatorname{Enc}, \operatorname{Dec})$ naturally gives a 2-message KE protocol: Alice runs $\operatorname{Gen}\to (pk, sk)$ and sends $pk$ to Bob; Bob picks random $m$ and sends $c = \operatorname{Enc}_{pk}(m)$ to Alice; Alice outputs $\operatorname{Dec}_{sk}(c)$ and Bob outputs $m$.', 'The security proof shows that if the PKE scheme is IND-CPA secure, then the resulting KE protocol is secure. The key insight is that the shared secret $m$ is computationally hidden from any eavesdropper due to the semantic security of the encryption scheme. The adversary cannot distinguish between the real protocol and one where a random message is encrypted.', ARRAY['pke'], ARRAY['ke'], ARRAY['public key', 'foundational', 'trivial'], 'plain', '[]', '', false);

-- Verify the import
SELECT 'Vertices imported:' as info, COUNT(*) as count FROM vertices
UNION ALL
SELECT 'Edges imported:' as info, COUNT(*) as count FROM edges; 